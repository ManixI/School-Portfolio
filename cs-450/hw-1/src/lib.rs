#![feature(slice_split_at_unchecked)]
#![feature(ascii_char)]
#![feature(ascii_char_variants)]
#![feature(byte_slice_trim_ascii)]

use std::{io::{self, BufRead, Read, BufReader}, ascii::Char, borrow::BorrowMut};
use std::fs::File;
use std::path::Path;

const MAX_SIZE: usize = 30;


// helper function, read file
fn read_lines<P>(filename: P) -> io::Result<io::Lines<io::BufReader<File>>>
where P: AsRef<Path>, {
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}

pub fn read_input_benchmark(data: &str) -> ([[f64; 30]; 30], usize) {
    let mut size = String::new();

    /*io::stdin()
        .read_line(&mut size)
        .expect("Could not read size");*/

    let mut lines = data.lines();
    let size = lines.next().unwrap();

    let size: usize = match size.trim().parse() {
        Ok(num) => num,
        Err(_) => panic!("Size entered was not a number")
    };

    // kind ot cheety, use stack based array for size 30 and less instead of heap
    //if size <= MAX_SIZE {
        let mut mat: [[f64; MAX_SIZE]; MAX_SIZE] = [[0.0; MAX_SIZE]; MAX_SIZE];
        let mut line = String::new();
        assert!(size <= mat.len());
        {
            // will unlock when dropped
            // aquire lock once instead of every loop
            let mut stdin_lock = std::io::stdin().lock();

            for row in mat.iter_mut().take(size) {
                // ref: https://stackoverflow.com/questions/30412521/how-to-read-a-specific-number-of-bytes-from-a-stream
                // start with empty sring every line
                line.clear();
                /*stdin_lock
                    .read_line(&mut line)
                    .expect("could not read line");*/
                line = lines.next().unwrap().to_string();

                // split line into characters on spaces, insert into matrix
                // TODO: could speed up by working with bytes instead of a String
                for (index, c) in line.split_ascii_whitespace().enumerate() {
                    row[index] = match c.parse() {
                        Ok(num) => num,
                        Err(_) => panic!("error in entered line"),
                    };
                }

            }
        // stdin lock dropped here
        }

    (mat, size)
}

// ref: https://www.reddit.com/r/rust/comments/sbmiv5/question_is_it_possible_to_speed_up_reading_from/hu173xp/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button
fn parse_num(s: &str) -> f64 {
    s.bytes().fold(0.0, |acc, curr| (acc*10.0) + (curr - b'0') as f64)
}

pub fn read_input_opt(data: &str) -> ([[f64; 30]; 30], usize) {
    let mut size = String::new();

    /*io::stdin()
        .read_line(&mut size)
        .expect("Could not read size");*/

    let mut lines = data.lines();
    let size = lines.next().unwrap();

    let size = parse_num(size.trim()) as usize;

    // kind ot cheety, use stack based array for size 30 and less instead of heap
    //if size <= MAX_SIZE {
        let mut mat: [[f64; MAX_SIZE]; MAX_SIZE] = [[0.0; MAX_SIZE]; MAX_SIZE];
        //let mut line = String::new();
        assert!(size <= mat.len());
        {
            // will unlock when dropped
            // aquire lock once instead of every loop
            let mut stdin_lock = std::io::stdin().lock();

            for row in mat.iter_mut().take(size) {
                // ref: https://stackoverflow.com/questions/30412521/how-to-read-a-specific-number-of-bytes-from-a-stream
                // start with empty sring every line
                //line.clear();
                /*stdin_lock
                    .read_line(&mut line)
                    .expect("could not read line");*/
                let line = lines.next().unwrap();

                // split line into characters on spaces, insert into matrix
                // TODO: could speed up by working with bytes instead of a String
                for (index, c) in line.split_ascii_whitespace().enumerate() {
                    row[index] = parse_num(c);
                }

            }
        // stdin lock dropped here
        }

    (mat, size)
}

pub fn read_input_opt_two(data: &str) -> ([[f64; 30]; 30], usize) {
    let mut size = String::new();

    // aquire lock once instead of for every input
    let mut stdin_lock = std::io::stdin().lock();

    let mut file = File::open(data).unwrap();
    let mut stdin_lock = BufReader::new(file);

    stdin_lock
        .read_line(&mut size)
        .expect("Could not read size");
    let size = parse_num_two(size.trim().as_bytes()) as usize;
    //let size = 30;

    let mut line = Vec::new();
    // kind ot cheety, use stack based array for size 30 and less instead of heap
    let mut mat: [[f64; MAX_SIZE]; MAX_SIZE] = [[0.0; MAX_SIZE]; MAX_SIZE];
    //let mut mat_iter = mat.iter_mut().take(size);
    {
        for row in mat.iter_mut().take(size) {
            // ref: https://stackoverflow.com/questions/30412521/how-to-read-a-specific-number-of-bytes-from-a-stream
            // start with empty sring every line
            line.clear();
            stdin_lock
                .read_until(b'\n', &mut line)
                //.read_line(&mut line)
                .expect("could not read line");

            // split line into characters on spaces, insert into matrix
            // TODO: could speed up by working with bytes instead of a String
            let entries = line
                .splitn(size, |c| c == &b' ')
                .take(size);
            for (index, c) in entries.enumerate() {
                row[index] = parse_num_two(c.trim_ascii());
            }
        }
    }
    (mat, size)
}

fn parse_num_two(s: &[u8]) -> f64 {
    s
        .bytes()
        .fold(0.0, |acc, curr| {
            (acc*10.0) + (curr.unwrap() - b'0') as f64 }
        )
}


pub fn calc_det(mut mat: [[f64; 30]; 30], size: usize) -> f64 {
    //let mut sign: u8 = 0;
    let mut sign = 1.0;

    // calc determinate
    // ref: https://en.wikipedia.org/wiki/LU_decomposition
    let mut abs_a;
    let mut tmp: [f64; MAX_SIZE];
    // not using itterator because allocate 30x30 for all mats
    // TODO: check speed of above vs vec of tuples
    for i in 0..size {
        let mut max_a = 0.0;
        let mut imax = i;

        for k in i..size {
            abs_a = mat[k][i].abs();
            if abs_a > max_a {
                max_a = abs_a;
                imax = k;
            }
        }

        if imax != i {
            // pivot mat
            // TODO: I think this is slow
            tmp = mat[i];
            mat[i] = mat[imax];
            mat[imax] = tmp;

            sign *= -1.0;
        }
        
        for j in (i+1)..size {
            mat[j][i] /= mat[i][i];
            
            for k in (i+1)..size {
                mat[j][k] -= mat[j][i] * mat[i][k]
            }
        }
    }
    /*for ln in mat {
        println!("{:?}", ln);
    }*/

    // actually calc determinate
    let mut det = mat[0][0];
    for i in 1..size {
        det *= mat[i][i];
    }
    /*if sign > 0 {
        det *= -1.0;
    }*/
    det *= sign;

    return det;
}

// can sort to trianlge form and then calc det, don't need to do more for test case
// cal calc det if not test case
// TODO: need to calc sign ref: https://codereview.stackexchange.com/questions/206158/minimum-number-of-swaps-required-to-sort-the-array-in-ascending-order
pub fn calc_det_single_opt(mut mat: [[f64; 30]; 30], size: usize) -> f64 {
    
    //let mut dest: [[f64; 30]; 30] = [[0.0; 30]; 30];
    //let mut checklist: u32 = 0;
    let mut det = 1.0;
    let mut positions: [usize; 30] = [0; 30];
    let mut sign = 1;
    // det will always be positive if in this form
    // for every line in mat
    for (index, line) in mat.iter().enumerate() {
        // count number of leading 0s
        //assert!(dest.len() >= line.len());
        for (pos, num) in line.iter().enumerate() {
            if num.ne(&0.0) {
                //dest[index] = line;
                det *= num;
                positions[index] = pos;
                //checklist |= 1 << index;
                break;
            }
        }
    }

    for i in 0..size {
        if positions[i] != i {
            for k in (i+1)..size {
                if positions[k] == i {
                    positions[k] = positions[i];
                    positions[i] = i;
                    sign *= -1;
                    break;

                }
            }
        }
    }

    // if matched expected form, return det, otherwise calc rigorous way
    /*match checklist {
        CHECKLIST_BITMASK => det,
        _ => calc_det(mat)
    }*/
    // all tests already in correct form, don't need to check if it wasn't
    det * sign as f64
    //det
}


//ref: https://cs.stackexchange.com/questions/124759/determinant-calculation-bareiss-vs-gauss-algorithm
pub fn calc_det_breiss(mut mat: [[f64; 30]; 30]) -> f64 {
    let mut sign: f64 = 1.0;
    let mut tmp: [f64; MAX_SIZE];

    for k in 0..(MAX_SIZE-1) {
        // row swap if needed
        let mut num = 0;
        if mat[k][k] == 0.0 {
            for m in (k+1)..MAX_SIZE {
                num = m;
                if mat[m][k] != 0.0 {
                    tmp = mat[m];
                    mat[m] = mat[k];
                    mat[k] = tmp;

                    sign *= -1.0;
                    break;
                }
            }

            if num == MAX_SIZE{
                return 0.0;
            }
            
        }

        for i in (k+1)..MAX_SIZE {
            for j in (k+1)..MAX_SIZE {
                mat[i][j] = mat[k][k] * mat[i][j] - mat[i][k] * mat[k][j];
                if k != 0 {
                    mat[i][j] /= mat[k-1][k-1];
                }
            }
        }
    }
    sign * mat[MAX_SIZE-1][MAX_SIZE-1]
}

const TEST_MAT_30: [[f64; 30]; 30] = [
    [0.0,0.0,0.0,0.0,0.0,1.0,10.0,7.0,1.0,2.0,4.0,6.0,9.0,10.0,2.0,9.0,8.0,5.0,2.0,10.0,8.0,4.0,3.0,2.0,10.0,2.0,5.0,10.0,9.0,9.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,5.0,9.0,10.0,2.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,6.0,2.0,6.0,3.0,2.0,8.0,10.0,9.0,4.0,9.0,10.0,7.0,1.0,8.0,8.0,5.0,1.0,10.0,5.0,8.0,9.0,6.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,4.0,9.0,10.0,5.0,1.0,8.0,3.0,6.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,5.0,6.0,6.0,9.0,5.0,2.0,10.0,2.0,5.0,8.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,8.0,8.0,10.0,6.0,10.0,7.0,7.0,6.0,9.0,2.0,10.0,10.0,3.0],
    [6.0,5.0,7.0,4.0,9.0,7.0,1.0,4.0,10.0,1.0,3.0,4.0,4.0,8.0,4.0,2.0,9.0,9.0,5.0,1.0,8.0,10.0,2.0,2.0,3.0,6.0,1.0,3.0,5.0,10.0],
    [0.0,4.0,5.0,8.0,9.0,2.0,4.0,3.0,2.0,3.0,3.0,3.0,4.0,1.0,10.0,5.0,3.0,4.0,8.0,3.0,10.0,8.0,9.0,9.0,1.0,7.0,7.0,4.0,8.0,2.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10.0,2.0,2.0,9.0,5.0,8.0,2.0,1.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,5.0,9.0,6.0,7.0,9.0,9.0,5.0,7.0,8.0,5.0,4.0,9.0,9.0,10.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,9.0,4.0,1.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10.0,8.0,10.0,10.0,5.0,10.0,8.0,5.0,2.0,9.0,9.0,7.0,5.0,9.0,8.0,7.0,9.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10.0,6.0,5.0,2.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,6.0,1.0,9.0,9.0,8.0,1.0,7.0,4.0,10.0,6.0,10.0,10.0,5.0,6.0,3.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,7.0,2.0,10.0,5.0,3.0,4.0,2.0,1.0,3.0,7.0,6.0,10.0,10.0,3.0,6.0,2.0,2.0,9.0,5.0,4.0,7.0,7.0,10.0,9.0],
    [0.0,0.0,0.0,3.0,4.0,7.0,4.0,3.0,10.0,3.0,6.0,8.0,10.0,2.0,6.0,4.0,5.0,8.0,9.0,7.0,6.0,2.0,9.0,6.0,8.0,9.0,9.0,10.0,6.0,2.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,9.0,7.0,3.0,6.0,4.0,9.0,4.0,8.0,8.0,2.0,1.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10.0,9.0,2.0,1.0,7.0,5.0,8.0,6.0,9.0,4.0,9.0,8.0,5.0,6.0,10.0,8.0,6.0,2.0,4.0,1.0,1.0],
    [0.0,0.0,2.0,5.0,2.0,1.0,3.0,6.0,8.0,6.0,3.0,1.0,1.0,2.0,10.0,10.0,3.0,2.0,6.0,6.0,1.0,6.0,9.0,5.0,8.0,9.0,8.0,4.0,8.0,2.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,10.0,5.0,9.0,4.0,7.0,8.0,3.0,5.0,8.0,3.0,4.0,2.0,1.0,2.0,10.0,8.0,9.0,1.0,1.0,5.0,10.0,7.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10.0,4.0,8.0,2.0,3.0,9.0,5.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,4.0],
    [0.0,0.0,0.0,0.0,6.0,1.0,3.0,2.0,3.0,2.0,3.0,7.0,1.0,2.0,4.0,7.0,10.0,8.0,5.0,7.0,2.0,4.0,2.0,3.0,9.0,4.0,1.0,5.0,9.0,4.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,4.0,1.0,5.0,10.0,3.0,5.0,10.0,8.0,4.0,6.0,6.0,1.0,10.0,6.0,4.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,5.0,6.0,9.0,1.0,1.0,4.0,8.0,6.0,6.0,5.0,7.0,10.0,6.0,4.0,2.0,3.0,8.0,9.0,1.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,5.0,3.0,8.0,8.0,8.0,7.0,2.0,10.0,10.0,1.0,7.0,2.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10.0,2.0,8.0,5.0,6.0,4.0,10.0,7.0,1.0,5.0,8.0,4.0,1.0,10.0,9.0,4.0,7.0,3.0,1.0,6.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,8.0,5.0,7.0,5.0,2.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,4.0,9.0,6.0,10.0,3.0,6.0,1.0,9.0,7.0,8.0,5.0,5.0,10.0,4.0,4.0,2.0,3.0,7.0],
];

const TEST_MAT_2: [[f64; 30]; 30] = [
    [1.0,4.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,9.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
];

const TEST_MAT_3: [[f64; 30]; 30] = [
    [2.0,6.0,2.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,10.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,3.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
];

const TEST_MAT_6: [[f64; 30]; 30] = [
    [0.0,0.0,0.0,0.0,0.0,9.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,6.0,10.0,10.0,2.0,8.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [8.0,8.0,2.0,10.0,5.0,9.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,5.0,4.0,3.0,4.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,1.0,8.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,10.0,7.0,5.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
    [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0],
];

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_input_benchmark() {
        let input = "30
0 0 0 0 0 1 10 7 1 2 4 6 9 10 2 9 8 5 2 10 8 4 3 2 10 2 5 10 9 9
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 5 9 10 2
0 0 0 0 0 0 0 0 6 2 6 3 2 8 10 9 4 9 10 7 1 8 8 5 1 10 5 8 9 6
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 4 9 10 5 1 8 3 6
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 6 6 9 5 2 10 2 5 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 10 6 10 7 7 6 9 2 10 10 3
6 5 7 4 9 7 1 4 10 1 3 4 4 8 4 2 9 9 5 1 8 10 2 2 3 6 1 3 5 10
0 4 5 8 9 2 4 3 2 3 3 3 4 1 10 5 3 4 8 3 10 8 9 9 1 7 7 4 8 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 2 2 9 5 8 2 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 9 6 7 9 9 5 7 8 5 4 9 9 10
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9 4 1
0 0 0 0 0 0 0 0 0 0 0 0 0 10 8 10 10 5 10 8 5 2 9 9 7 5 9 8 7 9
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 6 5 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 6 1 9 9 8 1 7 4 10 6 10 10 5 6 3
0 0 0 0 0 0 7 2 10 5 3 4 2 1 3 7 6 10 10 3 6 2 2 9 5 4 7 7 10 9
0 0 0 3 4 7 4 3 10 3 6 8 10 2 6 4 5 8 9 7 6 2 9 6 8 9 9 10 6 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9 7 3 6 4 9 4 8 8 2 1
0 0 0 0 0 0 0 0 0 10 9 2 1 7 5 8 6 9 4 9 8 5 6 10 8 6 2 4 1 1
0 0 2 5 2 1 3 6 8 6 3 1 1 2 10 10 3 2 6 6 1 6 9 5 8 9 8 4 8 2
0 0 0 0 0 0 0 3 10 5 9 4 7 8 3 5 8 3 4 2 1 2 10 8 9 1 1 5 10 7
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 4 8 2 3 9 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 4
0 0 0 0 6 1 3 2 3 2 3 7 1 2 4 7 10 8 5 7 2 4 2 3 9 4 1 5 9 4
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 1 5 10 3 5 10 8 4 6 6 1 10 6 4
0 0 0 0 0 0 0 0 0 0 0 5 6 9 1 1 4 8 6 6 5 7 10 6 4 2 3 8 9 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 3 8 8 8 7 2 10 10 1 7 2
0 0 0 0 0 0 0 0 0 0 10 2 8 5 6 4 10 7 1 5 8 4 1 10 9 4 7 3 1 6
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 8 5 7 5 2
0 0 0 0 0 0 0 0 0 0 0 0 4 9 6 10 3 6 1 9 7 8 5 5 10 4 4 2 3 7";
        let tmp = read_input_benchmark(input);
        assert_eq!(TEST_MAT_30, tmp.0);
    }

    #[test]
    fn test_input_opt() {
        let input = "30
0 0 0 0 0 1 10 7 1 2 4 6 9 10 2 9 8 5 2 10 8 4 3 2 10 2 5 10 9 9
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 5 9 10 2
0 0 0 0 0 0 0 0 6 2 6 3 2 8 10 9 4 9 10 7 1 8 8 5 1 10 5 8 9 6
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 4 9 10 5 1 8 3 6
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 6 6 9 5 2 10 2 5 8
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 8 8 10 6 10 7 7 6 9 2 10 10 3
6 5 7 4 9 7 1 4 10 1 3 4 4 8 4 2 9 9 5 1 8 10 2 2 3 6 1 3 5 10
0 4 5 8 9 2 4 3 2 3 3 3 4 1 10 5 3 4 8 3 10 8 9 9 1 7 7 4 8 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 2 2 9 5 8 2 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 9 6 7 9 9 5 7 8 5 4 9 9 10
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9 4 1
0 0 0 0 0 0 0 0 0 0 0 0 0 10 8 10 10 5 10 8 5 2 9 9 7 5 9 8 7 9
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 6 5 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 6 1 9 9 8 1 7 4 10 6 10 10 5 6 3
0 0 0 0 0 0 7 2 10 5 3 4 2 1 3 7 6 10 10 3 6 2 2 9 5 4 7 7 10 9
0 0 0 3 4 7 4 3 10 3 6 8 10 2 6 4 5 8 9 7 6 2 9 6 8 9 9 10 6 2
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 9 7 3 6 4 9 4 8 8 2 1
0 0 0 0 0 0 0 0 0 10 9 2 1 7 5 8 6 9 4 9 8 5 6 10 8 6 2 4 1 1
0 0 2 5 2 1 3 6 8 6 3 1 1 2 10 10 3 2 6 6 1 6 9 5 8 9 8 4 8 2
0 0 0 0 0 0 0 3 10 5 9 4 7 8 3 5 8 3 4 2 1 2 10 8 9 1 1 5 10 7
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 4 8 2 3 9 5
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 4
0 0 0 0 6 1 3 2 3 2 3 7 1 2 4 7 10 8 5 7 2 4 2 3 9 4 1 5 9 4
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 1 5 10 3 5 10 8 4 6 6 1 10 6 4
0 0 0 0 0 0 0 0 0 0 0 5 6 9 1 1 4 8 6 6 5 7 10 6 4 2 3 8 9 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 3 8 8 8 7 2 10 10 1 7 2
0 0 0 0 0 0 0 0 0 0 10 2 8 5 6 4 10 7 1 5 8 4 1 10 9 4 7 3 1 6
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 8 5 7 5 2
0 0 0 0 0 0 0 0 0 0 0 0 4 9 6 10 3 6 1 9 7 8 5 5 10 4 4 2 3 7";
        let tmp = read_input_opt(input);
        assert_eq!(TEST_MAT_30, tmp.0);
    }

    #[test]
    fn test_input_opt_two() {
        let input = "/home/ian/dev/cs-450/hw-1/src/30x30.txt";
        let tmp = read_input_opt_two(input);
        assert_eq!(TEST_MAT_30, tmp.0);
    }

    #[test]
    fn test_det() {
        assert_eq!(calc_det(TEST_MAT_30, 30), 19046845440000000000.0);
        assert_eq!(calc_det(TEST_MAT_2, 2), 9.0);
        assert_eq!(calc_det(TEST_MAT_3, 3), 60.0);
        assert_eq!(calc_det(TEST_MAT_6, 6), -21600.0);
    }

    #[test]
    fn test_det_single_opt() {
        assert_eq!(calc_det_single_opt(TEST_MAT_30, 30), 19046845440000000000.0);
        assert_eq!(calc_det_single_opt(TEST_MAT_2, 2), 9.0);
        assert_eq!(calc_det_single_opt(TEST_MAT_3, 3), 60.0);
        assert_eq!(calc_det_single_opt(TEST_MAT_6, 6), -21600.0);
    }

    #[test]
    fn test_det_breiss() {
        // failed bc floating point inprecision?

        let mat: [[f64; 30]; 30] = [
            [0.0,0.0,0.0,0.0,0.0,1.0,10.0,7.0,1.0,2.0,4.0,6.0,9.0,10.0,2.0,9.0,8.0,5.0,2.0,10.0,8.0,4.0,3.0,2.0,10.0,2.0,5.0,10.0,9.0,9.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,5.0,9.0,10.0,2.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,6.0,2.0,6.0,3.0,2.0,8.0,10.0,9.0,4.0,9.0,10.0,7.0,1.0,8.0,8.0,5.0,1.0,10.0,5.0,8.0,9.0,6.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,4.0,9.0,10.0,5.0,1.0,8.0,3.0,6.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,5.0,6.0,6.0,9.0,5.0,2.0,10.0,2.0,5.0,8.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,8.0,8.0,10.0,6.0,10.0,7.0,7.0,6.0,9.0,2.0,10.0,10.0,3.0],
            [6.0,5.0,7.0,4.0,9.0,7.0,1.0,4.0,10.0,1.0,3.0,4.0,4.0,8.0,4.0,2.0,9.0,9.0,5.0,1.0,8.0,10.0,2.0,2.0,3.0,6.0,1.0,3.0,5.0,10.0],
            [0.0,4.0,5.0,8.0,9.0,2.0,4.0,3.0,2.0,3.0,3.0,3.0,4.0,1.0,10.0,5.0,3.0,4.0,8.0,3.0,10.0,8.0,9.0,9.0,1.0,7.0,7.0,4.0,8.0,2.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10.0,2.0,2.0,9.0,5.0,8.0,2.0,1.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,5.0,9.0,6.0,7.0,9.0,9.0,5.0,7.0,8.0,5.0,4.0,9.0,9.0,10.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,9.0,4.0,1.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10.0,8.0,10.0,10.0,5.0,10.0,8.0,5.0,2.0,9.0,9.0,7.0,5.0,9.0,8.0,7.0,9.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10.0,6.0,5.0,2.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,6.0,1.0,9.0,9.0,8.0,1.0,7.0,4.0,10.0,6.0,10.0,10.0,5.0,6.0,3.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,7.0,2.0,10.0,5.0,3.0,4.0,2.0,1.0,3.0,7.0,6.0,10.0,10.0,3.0,6.0,2.0,2.0,9.0,5.0,4.0,7.0,7.0,10.0,9.0],
            [0.0,0.0,0.0,3.0,4.0,7.0,4.0,3.0,10.0,3.0,6.0,8.0,10.0,2.0,6.0,4.0,5.0,8.0,9.0,7.0,6.0,2.0,9.0,6.0,8.0,9.0,9.0,10.0,6.0,2.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,9.0,7.0,3.0,6.0,4.0,9.0,4.0,8.0,8.0,2.0,1.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10.0,9.0,2.0,1.0,7.0,5.0,8.0,6.0,9.0,4.0,9.0,8.0,5.0,6.0,10.0,8.0,6.0,2.0,4.0,1.0,1.0],
            [0.0,0.0,2.0,5.0,2.0,1.0,3.0,6.0,8.0,6.0,3.0,1.0,1.0,2.0,10.0,10.0,3.0,2.0,6.0,6.0,1.0,6.0,9.0,5.0,8.0,9.0,8.0,4.0,8.0,2.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,10.0,5.0,9.0,4.0,7.0,8.0,3.0,5.0,8.0,3.0,4.0,2.0,1.0,2.0,10.0,8.0,9.0,1.0,1.0,5.0,10.0,7.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10.0,4.0,8.0,2.0,3.0,9.0,5.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,3.0,4.0],
            [0.0,0.0,0.0,0.0,6.0,1.0,3.0,2.0,3.0,2.0,3.0,7.0,1.0,2.0,4.0,7.0,10.0,8.0,5.0,7.0,2.0,4.0,2.0,3.0,9.0,4.0,1.0,5.0,9.0,4.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,4.0,1.0,5.0,10.0,3.0,5.0,10.0,8.0,4.0,6.0,6.0,1.0,10.0,6.0,4.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,5.0,6.0,9.0,1.0,1.0,4.0,8.0,6.0,6.0,5.0,7.0,10.0,6.0,4.0,2.0,3.0,8.0,9.0,1.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,5.0,3.0,8.0,8.0,8.0,7.0,2.0,10.0,10.0,1.0,7.0,2.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,10.0,2.0,8.0,5.0,6.0,4.0,10.0,7.0,1.0,5.0,8.0,4.0,1.0,10.0,9.0,4.0,7.0,3.0,1.0,6.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,8.0,5.0,7.0,5.0,2.0],
            [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,4.0,9.0,6.0,10.0,3.0,6.0,1.0,9.0,7.0,8.0,5.0,5.0,10.0,4.0,4.0,2.0,3.0,7.0],
        ];

        assert_eq!(calc_det_breiss(mat), 19046845440000000000.0)
    }
}