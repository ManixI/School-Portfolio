\documentclass[sigconf]{article}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{helvet}
\usepackage{titlesec}
\usepackage{courier}


\graphicspath{ {./images/} }

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}


\begin{document}

\lstset{basicstyle=\footnotesize\ttfamily, language=c}

\titleformat{\section}
  {\normalfont\Large\bfseries}
  {\thesection}
  {1em}
  {}
  [{\titlerule[0.8pt]}]

\titleformat{\subsection}
  {\normalfont\Large\bfseries}
  {\thesection}
  {1em}
  {}
  [{\titlerule[0.3pt]}]

  \titleformat{\title}
  {\normalfont\Large\bfseries}
  {\thesection}
  {1em}
  {{\titlerule[0.8pt]}}
  [{\titlerule[0.8pt]}]

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Lab 1}
\author{
  \bold Ian Manix \\\
  }

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.

%%
%% The abstract is a short summary of the work to be presented in the
%% article.


%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
%%\keywords{}
%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.

%%\received{28 November 2022}
%%\received[revised]{N/A}
%%\received[accepted]{N/A}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.

\begin{center}
   \textbf{Hardware, Development Tools, and Blinking LED using FreeRTOS}

   \vspace{.75in}

   by

   \textbf{Ian Manix}

   \vspace{2in}

   CS 466

   LABRATORY REPORT

   \vspace{.75in}

   Computer Science, Washington State University

   February 10, 2023

\end{center}

\clearpage
\section*{Objectives}

\begin{enumerate}
    \item To discover that the RTOS helps organize and make your code more independent and flexible. 
    \item To interact with a multi-threaded program and synchronization with an asynchronous interrupt service
routine. 
    \item Use of \lstinline{printf()} to redirect serial type data over a USB port
\end{enumerate}


%\clearpage
\section*{Apparatus}

For this lab we used:
\begin{enumerate}
  \item 1 raspberry Pi pico 
  \item 1 breadboard
  \item 3 push button switches
  \item 7 jumper cables
\end{enumerate}

\includegraphics[scale=0.08]{images/setup.jpg}

Along with the two buttons necessary for the input, an additional third button was tied to the reset pin of the Pi so make resetting and re-uploading code easier.


\section*{Method}

To achieve the goals of this lab the FreeRTOS library was used to create, schedule, and call tasks. To create a task I created a global semaphore in the form of a \lstinline{SemaphoreHandle_t}, which was then initialized in main with the FreeRTOS function \lstinline{xSemaphoreCreateBinary();} creating a binary semaphore. Next I used \lstinline{xTaskCreate()} to create a thread and add a function on it. This function is also where the priority of the task is set. For tasks that can run in the background the process ends there. For tasks that wait on interrupts such as ones that react to button inputs, the function starts with \lstinline{xSemaphoreTake()} which stops the function until the semaphore it is watching is triggered. The semaphore is triggered with \lstinline{xSemaphoreGiveFromISR()}, and \lstinline{xSemaphoreTake()} waits until the semaphore it is watching is triggered a second time instead of continuing to pass until the state of the semaphore is changed back. The other key part of this lab was setting a callback function that is run anytime a button is pressed. This is done by using \lstinline{gpio_set_irq_enabled_with_callback()} on the initialized gpio pins. What this dose is setup an interrupt that calls the callback function you provided whenever a button press occurs. It is inside this callback function where semaphores are triggered to interact with the various threads. In many cases \lstinline{sleep_ms()} was used instead of \lstinline{vTaskDelay()} because the former pauses the program in general where as the latter pauses only the thread it is called in. This was used because in many instances the expected behavior is that the current blinking pattern is finished before a second pattern is started.


\section*{Data}

To ensure the LED was blinking at the correct frequency and for the correct number of times, \lstinline{printf()} statements were used to track what task the Pi was executing and where it was in said task. Here is some example output with the reminder delay is set to 6 seconds instead of 60 to speed up testing.

\includegraphics[scale=0.6]{images/serial-output.png}


\section*{Results and Analysis}

The initial behavior of the lab2.c program is to blink the LED at 2 Hz. Every time the button is pressed the rate of blinking doubles until it reaches a threshold, at which point it drops down to a frequency below 2 Hz and the cycle starts over again. This is not consistent as the button can bounce when pressed, causing multiple singles to be sent which gives the appearance that the flashing LED skips some steps in the process of looping though frequency. 


\section*{Conclusion}

This lab in it's objectives of successfully introducing me to RTOS, reading \lstinline{printf()} statements as serial data over a USB port, and using multi-threading to create a program that responds to asynchronous interrupts. I was able to create multiple tasks of different priorities that either occurred at set intervals or waited until an interrupt was received in the form of button input before overriding the heartbeat task. I was also able to read data output though the serial port and display it on the screen of my laptop.

\clearpage
\section*{Appendix}
\subsection*{Code}

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily, language=c,breaklines]
/**
 * @brief CS466 Lab1 Blink proigram based on pico blink example
 * 
 * Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

#include <stdio.h>

#include <FreeRTOS.h>
#include <task.h>
#include <semphr.h>

#include "hardware/gpio.h"
#include "pico/stdlib.h"

const uint8_t LED_PIN = 25;
const uint8_t SW1_PIN = 17;
const uint8_t SW2_PIN = 16;

uint32_t heartbeatDelay = 1000;  // ms
uint32_t debounceDelay = 25; // ms

int LED_ISFREE = 1;

int timer = 0;

static SemaphoreHandle_t _semBtn1 = NULL;
static SemaphoreHandle_t _semBtn2 = NULL;
static SemaphoreHandle_t _semRem = NULL;

void gpio_int_callback(uint gpio, uint32_t events_unused) 
{
    printf("sw1_callback: GPIO ISR %d\n", gpio);
    // on callback pass appropriate semaphore
    if (gpio == SW1_PIN) {
        xSemaphoreGiveFromISR(_semBtn1, NULL);
    } else if (gpio == SW2_PIN) {
        xSemaphoreGiveFromISR(_semBtn2, NULL);
    }
}

void hardware_init(void)
{
    const uint LED_PIN = PICO_DEFAULT_LED_PIN;
    gpio_init(LED_PIN);
    gpio_set_dir(LED_PIN, GPIO_OUT);

    gpio_init(SW1_PIN);
    gpio_pull_up(SW1_PIN);
    gpio_set_dir(SW1_PIN, GPIO_IN);
    gpio_set_irq_enabled_with_callback(SW1_PIN, GPIO_IRQ_EDGE_FALL, true, &gpio_int_callback);

    gpio_init(SW2_PIN);
    gpio_pull_up(SW2_PIN);
    gpio_set_dir(SW2_PIN, GPIO_IN);
    gpio_set_irq_enabled_with_callback(SW2_PIN, GPIO_IRQ_EDGE_FALL, true, &gpio_int_callback);
}

void sw1_handler(void * notUsed)
{
    while (true)
    {
        xSemaphoreTake( _semBtn1, portMAX_DELAY);
        // reset timer
        timer = 0;

        printf("sw1 Semaphore taken..\n");
        // flash led as per lab handout
        if (!gpio_get(SW2_PIN)) {
            printf("both\n");
            while(!gpio_get(SW2_PIN)) {
                printf("Blink!\n");
                gpio_put(LED_PIN, 0);
                sleep_ms(1000/10);
                gpio_put(LED_PIN, 1);
                sleep_ms(1000/10);
            }
        } else {
            for (int i=0; i<20; i++) {
                printf("%i ", i);
                gpio_put(LED_PIN, 0);
                sleep_ms(1000/15);
                gpio_put(LED_PIN, 1);
                sleep_ms(1000/15);
            }
            printf("\n");
        }
    }
}

void sw2_handler(void * notUsed)
{
    while (true)
    {
        xSemaphoreTake( _semBtn2, portMAX_DELAY);
        // reset timer
        timer = 0;    

        printf("sw2 Semaphore taken..\n");
        // flash led as per lab handout
        if (!gpio_get(SW1_PIN)) {
            printf("both\n");
            while(!gpio_get(SW1_PIN)) {
                printf("Blink!\n");
                gpio_put(LED_PIN, 0);
                sleep_ms(1000/2.5);
                gpio_put(LED_PIN, 1);
                sleep_ms(1000/2.5);
            }
        } else {
            for (int i=0; i<10; i++) {
                printf("%i ", i);
                gpio_put(LED_PIN, 0);
                sleep_ms(1000/15);
                gpio_put(LED_PIN, 1);
                sleep_ms(1000/15);
            }
            printf("\n");
        }
    }
}

void heartbeat(void * notUsed)
{   
    // setup to check button state
    while (true) {
        if (timer == 60) {
            printf("----------\n");
            printf("Reminder!\n");
            printf("----------\n");
            for (int i = 0; i < 20; i++){
                gpio_put(LED_PIN, 0);
                sleep_ms(1000/40);
                gpio_put(LED_PIN, 1);
                sleep_ms(1000/40);
                timer = 0;
            }
            // looks better if ends on LED off
            gpio_put(LED_PIN, 0);
            vTaskDelay(heartbeatDelay);  
        } else {
            if (LED_ISFREE) {
                printf("Heartbeat %i\n", timer);
                gpio_put(LED_PIN, 1);
                vTaskDelay(heartbeatDelay);
                timer++;
                gpio_put(LED_PIN, 0);
                vTaskDelay(heartbeatDelay);
                timer++;
            }
        }
    }
}

int main()
{
    stdio_init_all();
    printf("lab2 Hello!\n");
    hardware_init();

    _semBtn1 = xSemaphoreCreateBinary();
    _semBtn2 = xSemaphoreCreateBinary();
    _semRem = xSemaphoreCreateBinary();

    xTaskCreate(heartbeat, "LED_Task", 256, NULL, 1, NULL);
    xTaskCreate(sw1_handler, "SW1_Task", 256, NULL, 2, NULL);
    xTaskCreate(sw2_handler, "SW2_Task", 256, NULL, 2, NULL);

    vTaskStartScheduler();

    while(1){};
}

\end{lstlisting}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-base}

\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'.